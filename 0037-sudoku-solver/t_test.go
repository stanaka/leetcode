package main

import (
	"testing"
)

type testCase struct {
	input  [][]byte
	expect [][]byte
}

func TestAnswer(t *testing.T) {
	testCases := []testCase{
		{
			[][]byte{[]byte{'5', '3', '.', '.', '7', '.', '.', '.', '.'}, []byte{'6', '.', '.', '1', '9', '5', '.', '.', '.'}, []byte{'.', '9', '8', '.', '.', '.', '.', '6', '.'},
				[]byte{'8', '.', '.', '.', '6', '.', '.', '.', '3'}, []byte{'4', '.', '.', '8', '.', '3', '.', '.', '1'}, []byte{'7', '.', '.', '.', '2', '.', '.', '.', '6'},
				[]byte{'.', '6', '.', '.', '.', '.', '2', '8', '.'}, []byte{'.', '.', '.', '4', '1', '9', '.', '.', '5'}, []byte{'.', '.', '.', '.', '8', '.', '.', '7', '9'}},
			[][]byte{[]byte{'5', '3', '4', '6', '7', '8', '9', '1', '2'}, []byte{'6', '7', '2', '1', '9', '5', '3', '4', '8'}, []byte{'1', '9', '8', '3', '4', '2', '5', '6', '7'},
				[]byte{'8', '5', '9', '7', '6', '1', '4', '2', '3'}, []byte{'4', '2', '6', '8', '5', '3', '7', '9', '1'}, []byte{'7', '1', '3', '9', '2', '4', '8', '5', '6'},
				[]byte{'9', '6', '1', '5', '3', '7', '2', '8', '4'}, []byte{'2', '8', '7', '4', '1', '9', '6', '3', '5'}, []byte{'3', '4', '5', '2', '8', '6', '1', '7', '9'}},
		},
		{[][]byte{[]byte{'.', '.', '9', '7', '4', '8', '.', '.', '.'}, []byte{'7', '.', '.', '.', '.', '.', '.', '.', '.'}, []byte{'.', '2', '.', '1', '.', '9', '.', '.', '.'},
			[]byte{'.', '.', '7', '.', '.', '.', '2', '4', '.'}, []byte{'.', '6', '4', '.', '1', '.', '5', '9', '.'}, []byte{'.', '9', '8', '.', '.', '.', '3', '.', '.'},
			[]byte{'.', '.', '.', '8', '.', '3', '.', '2', '.'}, []byte{'.', '.', '.', '.', '.', '.', '.', '.', '6'}, []byte{'.', '.', '.', '2', '7', '5', '9', '.', '.'}},
			[][]byte{[]byte{'5', '1', '9', '7', '4', '8', '6', '3', '2'}, []byte{'7', '8', '3', '6', '5', '2', '4', '1', '9'}, []byte{'4', '2', '6', '1', '3', '9', '8', '7', '5'},
				[]byte{'3', '5', '7', '9', '8', '6', '2', '4', '1'}, []byte{'2', '6', '4', '3', '1', '7', '5', '9', '8'}, []byte{'1', '9', '8', '5', '2', '4', '3', '6', '7'},
				[]byte{'9', '7', '5', '8', '6', '3', '1', '2', '4'}, []byte{'8', '3', '2', '4', '9', '1', '7', '5', '6'}, []byte{'6', '4', '1', '2', '7', '5', '9', '8', '3'}},
		},

		// [["5","1","9","7","4","8","6","3","2"],
		//  ["7","8","3","6","5","2","4","1","9"],
		//  ["4","2","6","1","3","9","8","7","5"],
		//  ["3","5","7","9","8","6","2","4","1"],
		//  ["2","6","4","3","1","7","5","9","8"],
		//  ["1","9","8","5","2","4","3","6","7"],
		//  ["9","7","5","8","6","3","1","2","4"],
		//  ["8","3","2","4","9","1","7","5","6"],
		//  ["6","4","1","2","7","5","9","8","3"]]
		{[][]byte{[]byte{'.', '.', '.', '2', '.', '.', '.', '6', '3'}, []byte{'3', '.', '.', '.', '.', '5', '4', '.', '1'}, []byte{'.', '.', '1', '.', '.', '3', '9', '8', '.'},
			[]byte{'.', '.', '.', '.', '.', '.', '.', '9', '.'}, []byte{'.', '.', '.', '5', '3', '8', '.', '.', '.'}, []byte{'.', '3', '.', '.', '.', '.', '.', '.', '.'},
			[]byte{'.', '2', '6', '3', '.', '.', '5', '.', '.'}, []byte{'5', '.', '3', '7', '.', '.', '.', '.', '8'}, []byte{'4', '7', '.', '.', '.', '1', '.', '.', '.'}},
			[][]byte{[]byte{'8', '5', '4', '2', '1', '9', '7', '6', '3'}, []byte{'3', '9', '7', '8', '6', '5', '4', '2', '1'}, []byte{'2', '6', '1', '4', '7', '3', '9', '8', '5'},
				[]byte{'7', '8', '5', '1', '2', '6', '3', '9', '4'}, []byte{'6', '4', '9', '5', '3', '8', '1', '7', '2'}, []byte{'1', '3', '2', '9', '4', '7', '8', '5', '6'},
				[]byte{'9', '2', '6', '3', '8', '4', '5', '1', '7'}, []byte{'5', '1', '3', '7', '9', '2', '6', '4', '8'}, []byte{'4', '7', '8', '6', '5', '1', '2', '3', '9'}},
		},
	}

	for i, v := range testCases {
		solveSudoku(v.input)
		for j := range v.input {
			for k := range v.input[j] {
				if v.input[j][k] != v.expect[j][k] {
					t.Errorf("case[%d]: expect %v, but %v", i+1, v.expect, v.input)
					return
				}
			}
		}
	}
}

/*
func TestAnswer2(t *testing.T) {
	input := ""
	words := []string{}
	for i := 0; i < 5000; i++ {
		input = input + "a"
		words = append(words, "a")
	}
	//expect := 399980000
	_ = findSubstring(input, words)
	//if output != expect {
	//	t.Errorf("case: expect %v, but %v", expect, output)
	//}
}
*/
